{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar commentRx = /^\\s*\\/(?:\\/|\\*)[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+;)?base64,(.*)$/mg;\nvar mapFileCommentRx =\n//Example (Extra space between slashes added to solve Safari bug. Exclude space in production):\n//     / /# sourceMappingURL=foo.js.map           /*# sourceMappingURL=foo.js.map */\n/(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/){1}[ \\t]*$)/mg;\nfunction decodeBase64(base64) {\n  return new Buffer(base64, 'base64').toString();\n}\nfunction stripComment(sm) {\n  return sm.split(',').pop();\n}\nfunction readFromFileMap(sm, dir) {\n  // NOTE: this will only work on the server since it attempts to read the map file\n\n  var r = mapFileCommentRx.exec(sm);\n  mapFileCommentRx.lastIndex = 0;\n\n  // for some odd reason //# .. captures in 1 and /* .. */ in 2\n  var filename = r[1] || r[2];\n  var filepath = path.join(dir, filename);\n  try {\n    return fs.readFileSync(filepath, 'utf8');\n  } catch (e) {\n    throw new Error('An error occurred while trying to read the map file at ' + filepath + '\\n' + e);\n  }\n}\nfunction Converter(sm, opts) {\n  opts = opts || {};\n  if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);\n  if (opts.hasComment) sm = stripComment(sm);\n  if (opts.isEncoded) sm = decodeBase64(sm);\n  if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);\n  this.sourcemap = sm;\n}\nfunction convertFromLargeSource(content) {\n  var lines = content.split('\\n');\n  var line;\n  // find first line which contains a source map starting at end of content\n  for (var i = lines.length - 1; i > 0; i--) {\n    line = lines[i];\n    if (~line.indexOf('sourceMappingURL=data:')) return exports.fromComment(line);\n  }\n}\nConverter.prototype.toJSON = function (space) {\n  return JSON.stringify(this.sourcemap, null, space);\n};\nConverter.prototype.toBase64 = function () {\n  var json = this.toJSON();\n  return new Buffer(json).toString('base64');\n};\nConverter.prototype.toComment = function (options) {\n  var base64 = this.toBase64();\n  var data = 'sourceMappingURL=data:application/json;base64,' + base64;\n  return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;\n};\n\n// returns copy instead of original\nConverter.prototype.toObject = function () {\n  return JSON.parse(this.toJSON());\n};\nConverter.prototype.addProperty = function (key, value) {\n  if (this.sourcemap.hasOwnProperty(key)) throw new Error('property %s already exists on the sourcemap, use set property instead');\n  return this.setProperty(key, value);\n};\nConverter.prototype.setProperty = function (key, value) {\n  this.sourcemap[key] = value;\n  return this;\n};\nConverter.prototype.getProperty = function (key) {\n  return this.sourcemap[key];\n};\nexports.fromObject = function (obj) {\n  return new Converter(obj);\n};\nexports.fromJSON = function (json) {\n  return new Converter(json, {\n    isJSON: true\n  });\n};\nexports.fromBase64 = function (base64) {\n  return new Converter(base64, {\n    isEncoded: true\n  });\n};\nexports.fromComment = function (comment) {\n  comment = comment.replace(/^\\/\\*/g, '//').replace(/\\*\\/$/g, '');\n  return new Converter(comment, {\n    isEncoded: true,\n    hasComment: true\n  });\n};\nexports.fromMapFileComment = function (comment, dir) {\n  return new Converter(comment, {\n    commentFileDir: dir,\n    isFileComment: true,\n    isJSON: true\n  });\n};\n\n// Finds last sourcemap comment in file or returns null if none was found\nexports.fromSource = function (content, largeSource) {\n  if (largeSource) {\n    var res = convertFromLargeSource(content);\n    return res ? res : null;\n  }\n  var m = content.match(commentRx);\n  commentRx.lastIndex = 0;\n  return m ? exports.fromComment(m.pop()) : null;\n};\n\n// Finds last sourcemap comment in file or returns null if none was found\nexports.fromMapFileSource = function (content, dir) {\n  var m = content.match(mapFileCommentRx);\n  mapFileCommentRx.lastIndex = 0;\n  return m ? exports.fromMapFileComment(m.pop(), dir) : null;\n};\nexports.removeComments = function (src) {\n  commentRx.lastIndex = 0;\n  return src.replace(commentRx, '');\n};\nexports.removeMapFileComments = function (src) {\n  mapFileCommentRx.lastIndex = 0;\n  return src.replace(mapFileCommentRx, '');\n};\nObject.defineProperty(exports, 'commentRegex', {\n  get: function getCommentRegex() {\n    commentRx.lastIndex = 0;\n    return commentRx;\n  }\n});\nObject.defineProperty(exports, 'mapFileCommentRegex', {\n  get: function getMapFileCommentRegex() {\n    mapFileCommentRx.lastIndex = 0;\n    return mapFileCommentRx;\n  }\n});","map":{"version":3,"names":["fs","require","path","commentRx","mapFileCommentRx","decodeBase64","base64","Buffer","toString","stripComment","sm","split","pop","readFromFileMap","dir","r","exec","lastIndex","filename","filepath","join","readFileSync","e","Error","Converter","opts","isFileComment","commentFileDir","hasComment","isEncoded","isJSON","JSON","parse","sourcemap","convertFromLargeSource","content","lines","line","i","length","indexOf","exports","fromComment","prototype","toJSON","space","stringify","toBase64","json","toComment","options","data","multiline","toObject","addProperty","key","value","hasOwnProperty","setProperty","getProperty","fromObject","obj","fromJSON","fromBase64","comment","replace","fromMapFileComment","fromSource","largeSource","res","m","match","fromMapFileSource","removeComments","src","removeMapFileComments","Object","defineProperty","get","getCommentRegex","getMapFileCommentRegex"],"sources":["C:/Users/straw/Desktop/Personal CS Projects/ZTM/Web Developer Course/face-recognition/node_modules/combine-source-map/node_modules/convert-source-map/index.js"],"sourcesContent":["'use strict';\nvar fs = require('fs');\nvar path = require('path');\n\nvar commentRx = /^\\s*\\/(?:\\/|\\*)[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+;)?base64,(.*)$/mg;\nvar mapFileCommentRx =\n  //Example (Extra space between slashes added to solve Safari bug. Exclude space in production):\n  //     / /# sourceMappingURL=foo.js.map           /*# sourceMappingURL=foo.js.map */\n  /(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/){1}[ \\t]*$)/mg\n\nfunction decodeBase64(base64) {\n  return new Buffer(base64, 'base64').toString();\n}\n\nfunction stripComment(sm) {\n  return sm.split(',').pop();\n}\n\nfunction readFromFileMap(sm, dir) {\n  // NOTE: this will only work on the server since it attempts to read the map file\n\n  var r = mapFileCommentRx.exec(sm);\n  mapFileCommentRx.lastIndex = 0;\n\n  // for some odd reason //# .. captures in 1 and /* .. */ in 2\n  var filename = r[1] || r[2];\n  var filepath = path.join(dir, filename);\n\n  try {\n    return fs.readFileSync(filepath, 'utf8');\n  } catch (e) {\n    throw new Error('An error occurred while trying to read the map file at ' + filepath + '\\n' + e);\n  }\n}\n\nfunction Converter (sm, opts) {\n  opts = opts || {};\n\n  if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);\n  if (opts.hasComment) sm = stripComment(sm);\n  if (opts.isEncoded) sm = decodeBase64(sm);\n  if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);\n\n  this.sourcemap = sm;\n}\n\nfunction convertFromLargeSource(content){\n  var lines = content.split('\\n');\n  var line;\n  // find first line which contains a source map starting at end of content\n  for (var i = lines.length - 1; i > 0; i--) {\n    line = lines[i]\n    if (~line.indexOf('sourceMappingURL=data:')) return exports.fromComment(line);\n  }\n}\n\nConverter.prototype.toJSON = function (space) {\n  return JSON.stringify(this.sourcemap, null, space);\n};\n\nConverter.prototype.toBase64 = function () {\n  var json = this.toJSON();\n  return new Buffer(json).toString('base64');\n};\n\nConverter.prototype.toComment = function (options) {\n  var base64 = this.toBase64();\n  var data = 'sourceMappingURL=data:application/json;base64,' + base64;\n  return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;\n};\n\n// returns copy instead of original\nConverter.prototype.toObject = function () {\n  return JSON.parse(this.toJSON());\n};\n\nConverter.prototype.addProperty = function (key, value) {\n  if (this.sourcemap.hasOwnProperty(key)) throw new Error('property %s already exists on the sourcemap, use set property instead');\n  return this.setProperty(key, value);\n};\n\nConverter.prototype.setProperty = function (key, value) {\n  this.sourcemap[key] = value;\n  return this;\n};\n\nConverter.prototype.getProperty = function (key) {\n  return this.sourcemap[key];\n};\n\nexports.fromObject = function (obj) {\n  return new Converter(obj);\n};\n\nexports.fromJSON = function (json) {\n  return new Converter(json, { isJSON: true });\n};\n\nexports.fromBase64 = function (base64) {\n  return new Converter(base64, { isEncoded: true });\n};\n\nexports.fromComment = function (comment) {\n  comment = comment\n    .replace(/^\\/\\*/g, '//')\n    .replace(/\\*\\/$/g, '');\n\n  return new Converter(comment, { isEncoded: true, hasComment: true });\n};\n\nexports.fromMapFileComment = function (comment, dir) {\n  return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });\n};\n\n// Finds last sourcemap comment in file or returns null if none was found\nexports.fromSource = function (content, largeSource) {\n  if (largeSource) {\n    var res = convertFromLargeSource(content);\n    return res ? res : null;\n  }\n\n  var m = content.match(commentRx);\n  commentRx.lastIndex = 0;\n  return m ? exports.fromComment(m.pop()) : null;\n};\n\n// Finds last sourcemap comment in file or returns null if none was found\nexports.fromMapFileSource = function (content, dir) {\n  var m = content.match(mapFileCommentRx);\n  mapFileCommentRx.lastIndex = 0;\n  return m ? exports.fromMapFileComment(m.pop(), dir) : null;\n};\n\nexports.removeComments = function (src) {\n  commentRx.lastIndex = 0;\n  return src.replace(commentRx, '');\n};\n\nexports.removeMapFileComments = function (src) {\n  mapFileCommentRx.lastIndex = 0;\n  return src.replace(mapFileCommentRx, '');\n};\n\nObject.defineProperty(exports, 'commentRegex', {\n  get: function getCommentRegex () {\n    commentRx.lastIndex = 0;\n    return commentRx;\n  }\n});\n\nObject.defineProperty(exports, 'mapFileCommentRegex', {\n  get: function getMapFileCommentRegex () {\n    mapFileCommentRx.lastIndex = 0;\n    return mapFileCommentRx;\n  }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}