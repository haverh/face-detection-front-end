{"ast":null,"code":"var assert = require('assert');\n\n/**\n * Get a list of all identifiers that are initialised by this (possibly destructuring)\n * node.\n *\n * eg with input:\n *\n * var { a: [b, ...c], d } = xyz\n *\n * this returns the nodes for 'b', 'c', and 'd'\n */\nmodule.exports = function getAssignedIdentifiers(node, identifiers) {\n  assert.equal(typeof node, 'object', 'get-assigned-identifiers: node must be object');\n  assert.equal(typeof node.type, 'string', 'get-assigned-identifiers: node must have a type');\n  identifiers = identifiers || [];\n  if (node.type === 'ImportDeclaration') {\n    node.specifiers.forEach(function (el) {\n      getAssignedIdentifiers(el, identifiers);\n    });\n  }\n  if (node.type === 'ImportDefaultSpecifier' || node.type === 'ImportNamespaceSpecifier' || node.type === 'ImportSpecifier') {\n    node = node.local;\n  }\n  if (node.type === 'RestElement') {\n    node = node.argument;\n  }\n  if (node.type === 'ArrayPattern') {\n    node.elements.forEach(function (el) {\n      // `el` might be `null` in case of `[x,,y] = whatever`\n      if (el) {\n        getAssignedIdentifiers(el, identifiers);\n      }\n    });\n  }\n  if (node.type === 'ObjectPattern') {\n    node.properties.forEach(function (prop) {\n      if (prop.type === 'Property') {\n        getAssignedIdentifiers(prop.value, identifiers);\n      } else if (prop.type === 'RestElement') {\n        getAssignedIdentifiers(prop, identifiers);\n      }\n    });\n  }\n  if (node.type === 'Identifier') {\n    identifiers.push(node);\n  }\n  return identifiers;\n};","map":{"version":3,"names":["assert","require","module","exports","getAssignedIdentifiers","node","identifiers","equal","type","specifiers","forEach","el","local","argument","elements","properties","prop","value","push"],"sources":["C:/Users/straw/Desktop/Personal CS Projects/ZTM/Web Developer Course/face-recognition/node_modules/get-assigned-identifiers/index.js"],"sourcesContent":["var assert = require('assert')\n\n/**\n * Get a list of all identifiers that are initialised by this (possibly destructuring)\n * node.\n *\n * eg with input:\n *\n * var { a: [b, ...c], d } = xyz\n *\n * this returns the nodes for 'b', 'c', and 'd'\n */\nmodule.exports = function getAssignedIdentifiers (node, identifiers) {\n  assert.equal(typeof node, 'object', 'get-assigned-identifiers: node must be object')\n  assert.equal(typeof node.type, 'string', 'get-assigned-identifiers: node must have a type')\n\n  identifiers = identifiers || []\n\n  if (node.type === 'ImportDeclaration') {\n    node.specifiers.forEach(function (el) {\n      getAssignedIdentifiers(el, identifiers)\n    })\n  }\n\n  if (node.type === 'ImportDefaultSpecifier' || node.type === 'ImportNamespaceSpecifier' || node.type === 'ImportSpecifier') {\n    node = node.local\n  }\n\n  if (node.type === 'RestElement') {\n    node = node.argument\n  }\n\n  if (node.type === 'ArrayPattern') {\n    node.elements.forEach(function (el) {\n      // `el` might be `null` in case of `[x,,y] = whatever`\n      if (el) {\n        getAssignedIdentifiers(el, identifiers)\n      }\n    })\n  }\n\n  if (node.type === 'ObjectPattern') {\n    node.properties.forEach(function (prop) {\n      if (prop.type === 'Property') {\n        getAssignedIdentifiers(prop.value, identifiers)\n      } else if (prop.type === 'RestElement') {\n        getAssignedIdentifiers(prop, identifiers)\n      }\n    })\n  }\n\n  if (node.type === 'Identifier') {\n    identifiers.push(node)\n  }\n\n  return identifiers\n}\n"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAG,SAASC,sBAAsB,CAAEC,IAAI,EAAEC,WAAW,EAAE;EACnEN,MAAM,CAACO,KAAK,CAAC,OAAOF,IAAI,EAAE,QAAQ,EAAE,+CAA+C,CAAC;EACpFL,MAAM,CAACO,KAAK,CAAC,OAAOF,IAAI,CAACG,IAAI,EAAE,QAAQ,EAAE,iDAAiD,CAAC;EAE3FF,WAAW,GAAGA,WAAW,IAAI,EAAE;EAE/B,IAAID,IAAI,CAACG,IAAI,KAAK,mBAAmB,EAAE;IACrCH,IAAI,CAACI,UAAU,CAACC,OAAO,CAAC,UAAUC,EAAE,EAAE;MACpCP,sBAAsB,CAACO,EAAE,EAAEL,WAAW,CAAC;IACzC,CAAC,CAAC;EACJ;EAEA,IAAID,IAAI,CAACG,IAAI,KAAK,wBAAwB,IAAIH,IAAI,CAACG,IAAI,KAAK,0BAA0B,IAAIH,IAAI,CAACG,IAAI,KAAK,iBAAiB,EAAE;IACzHH,IAAI,GAAGA,IAAI,CAACO,KAAK;EACnB;EAEA,IAAIP,IAAI,CAACG,IAAI,KAAK,aAAa,EAAE;IAC/BH,IAAI,GAAGA,IAAI,CAACQ,QAAQ;EACtB;EAEA,IAAIR,IAAI,CAACG,IAAI,KAAK,cAAc,EAAE;IAChCH,IAAI,CAACS,QAAQ,CAACJ,OAAO,CAAC,UAAUC,EAAE,EAAE;MAClC;MACA,IAAIA,EAAE,EAAE;QACNP,sBAAsB,CAACO,EAAE,EAAEL,WAAW,CAAC;MACzC;IACF,CAAC,CAAC;EACJ;EAEA,IAAID,IAAI,CAACG,IAAI,KAAK,eAAe,EAAE;IACjCH,IAAI,CAACU,UAAU,CAACL,OAAO,CAAC,UAAUM,IAAI,EAAE;MACtC,IAAIA,IAAI,CAACR,IAAI,KAAK,UAAU,EAAE;QAC5BJ,sBAAsB,CAACY,IAAI,CAACC,KAAK,EAAEX,WAAW,CAAC;MACjD,CAAC,MAAM,IAAIU,IAAI,CAACR,IAAI,KAAK,aAAa,EAAE;QACtCJ,sBAAsB,CAACY,IAAI,EAAEV,WAAW,CAAC;MAC3C;IACF,CAAC,CAAC;EACJ;EAEA,IAAID,IAAI,CAACG,IAAI,KAAK,YAAY,EAAE;IAC9BF,WAAW,CAACY,IAAI,CAACb,IAAI,CAAC;EACxB;EAEA,OAAOC,WAAW;AACpB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}