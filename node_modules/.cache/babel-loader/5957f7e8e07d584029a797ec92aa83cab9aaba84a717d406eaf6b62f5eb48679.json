{"ast":null,"code":"/* Generated by `npm run build`, do not edit! */\n\n\"use strict\";\n\nvar acorn = require(\"acorn\");\nvar tt = acorn.tokTypes;\nvar privateClassElements = require(\"../private-class-elements\");\nfunction maybeParseFieldValue(field) {\n  if (this.eat(tt.eq)) {\n    var oldInFieldValue = this._inFieldValue;\n    this._inFieldValue = true;\n    field.value = this.parseExpression();\n    this._inFieldValue = oldInFieldValue;\n  } else {\n    field.value = null;\n  }\n}\nmodule.exports = function (Parser) {\n  Parser = privateClassElements(Parser);\n  return /*@__PURE__*/function (Parser) {\n    function anonymous() {\n      Parser.apply(this, arguments);\n    }\n    if (Parser) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create(Parser && Parser.prototype);\n    anonymous.prototype.constructor = anonymous;\n    anonymous.prototype.parseClassElement = function parseClassElement(_constructorAllowsSuper) {\n      if (this.options.ecmaVersion >= 8 && (this.type == tt.name || this.type == this.privateNameToken || this.type == tt.bracketL || this.type == tt.string)) {\n        var branch = this._branch();\n        if (branch.type == tt.bracketL) {\n          var count = 0;\n          do {\n            if (branch.eat(tt.bracketL)) {\n              ++count;\n            } else if (branch.eat(tt.bracketR)) {\n              --count;\n            } else {\n              branch.next();\n            }\n          } while (count > 0);\n        } else {\n          branch.next();\n        }\n        if (branch.type == tt.eq || branch.canInsertSemicolon() || branch.type == tt.semi) {\n          var node = this.startNode();\n          if (this.type == this.privateNameToken) {\n            this.parsePrivateClassElementName(node);\n          } else {\n            this.parsePropertyName(node);\n          }\n          if (node.key.type === \"Identifier\" && node.key.name === \"constructor\" || node.key.type === \"Literal\" && node.key.value === \"constructor\") {\n            this.raise(node.key.start, \"Classes may not have a field called constructor\");\n          }\n          maybeParseFieldValue.call(this, node);\n          this.finishNode(node, \"FieldDefinition\");\n          this.semicolon();\n          return node;\n        }\n      }\n      return Parser.prototype.parseClassElement.apply(this, arguments);\n    };\n\n    // Prohibit arguments in class field initializers\n    anonymous.prototype.parseIdent = function parseIdent(liberal, isBinding) {\n      var ident = Parser.prototype.parseIdent.call(this, liberal, isBinding);\n      if (this._inFieldValue && ident.name == \"arguments\") {\n        this.raise(ident.start, \"A class field initializer may not contain arguments\");\n      }\n      return ident;\n    };\n    return anonymous;\n  }(Parser);\n};","map":{"version":3,"names":["acorn","require","tt","tokTypes","privateClassElements","maybeParseFieldValue","field","eat","eq","oldInFieldValue","_inFieldValue","value","parseExpression","module","exports","Parser","anonymous","apply","arguments","__proto__","prototype","Object","create","constructor","parseClassElement","_constructorAllowsSuper","options","ecmaVersion","type","name","privateNameToken","bracketL","string","branch","_branch","count","bracketR","next","canInsertSemicolon","semi","node","startNode","parsePrivateClassElementName","parsePropertyName","key","raise","start","call","finishNode","semicolon","parseIdent","liberal","isBinding","ident"],"sources":["C:/Users/straw/Desktop/Personal CS Projects/ZTM/Web Developer Course/face-recognition/node_modules/acorn-node/lib/class-fields/index.js"],"sourcesContent":["/* Generated by `npm run build`, do not edit! */\n\n\"use strict\"\n\nvar acorn = require(\"acorn\")\nvar tt = acorn.tokTypes\nvar privateClassElements = require(\"../private-class-elements\")\n\nfunction maybeParseFieldValue(field) {\n  if (this.eat(tt.eq)) {\n    var oldInFieldValue = this._inFieldValue\n    this._inFieldValue = true\n    field.value = this.parseExpression()\n    this._inFieldValue = oldInFieldValue\n  } else { field.value = null }\n}\n\nmodule.exports = function(Parser) {\n  Parser = privateClassElements(Parser)\n  return /*@__PURE__*/(function (Parser) {\n    function anonymous () {\n      Parser.apply(this, arguments);\n    }\n\n    if ( Parser ) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create( Parser && Parser.prototype );\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.parseClassElement = function parseClassElement (_constructorAllowsSuper) {\n      if (this.options.ecmaVersion >= 8 && (this.type == tt.name || this.type == this.privateNameToken || this.type == tt.bracketL || this.type == tt.string)) {\n        var branch = this._branch()\n        if (branch.type == tt.bracketL) {\n          var count = 0\n          do {\n            if (branch.eat(tt.bracketL)) { ++count }\n            else if (branch.eat(tt.bracketR)) { --count }\n            else { branch.next() }\n          } while (count > 0)\n        } else { branch.next() }\n        if (branch.type == tt.eq || branch.canInsertSemicolon() || branch.type == tt.semi) {\n          var node = this.startNode()\n          if (this.type == this.privateNameToken) {\n            this.parsePrivateClassElementName(node)\n          } else {\n            this.parsePropertyName(node)\n          }\n          if ((node.key.type === \"Identifier\" && node.key.name === \"constructor\") ||\n              (node.key.type === \"Literal\" && node.key.value === \"constructor\")) {\n            this.raise(node.key.start, \"Classes may not have a field called constructor\")\n          }\n          maybeParseFieldValue.call(this, node)\n          this.finishNode(node, \"FieldDefinition\")\n          this.semicolon()\n          return node\n        }\n      }\n\n      return Parser.prototype.parseClassElement.apply(this, arguments)\n    };\n\n    // Prohibit arguments in class field initializers\n    anonymous.prototype.parseIdent = function parseIdent (liberal, isBinding) {\n      var ident = Parser.prototype.parseIdent.call(this, liberal, isBinding)\n      if (this._inFieldValue && ident.name == \"arguments\") { this.raise(ident.start, \"A class field initializer may not contain arguments\") }\n      return ident\n    };\n\n    return anonymous;\n  }(Parser))\n}\n"],"mappings":"AAAA;;AAEA,YAAY;;AAEZ,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC5B,IAAIC,EAAE,GAAGF,KAAK,CAACG,QAAQ;AACvB,IAAIC,oBAAoB,GAAGH,OAAO,CAAC,2BAA2B,CAAC;AAE/D,SAASI,oBAAoB,CAACC,KAAK,EAAE;EACnC,IAAI,IAAI,CAACC,GAAG,CAACL,EAAE,CAACM,EAAE,CAAC,EAAE;IACnB,IAAIC,eAAe,GAAG,IAAI,CAACC,aAAa;IACxC,IAAI,CAACA,aAAa,GAAG,IAAI;IACzBJ,KAAK,CAACK,KAAK,GAAG,IAAI,CAACC,eAAe,EAAE;IACpC,IAAI,CAACF,aAAa,GAAGD,eAAe;EACtC,CAAC,MAAM;IAAEH,KAAK,CAACK,KAAK,GAAG,IAAI;EAAC;AAC9B;AAEAE,MAAM,CAACC,OAAO,GAAG,UAASC,MAAM,EAAE;EAChCA,MAAM,GAAGX,oBAAoB,CAACW,MAAM,CAAC;EACrC,OAAO,aAAc,UAAUA,MAAM,EAAE;IACrC,SAASC,SAAS,GAAI;MACpBD,MAAM,CAACE,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IAC/B;IAEA,IAAKH,MAAM,EAAGC,SAAS,CAACG,SAAS,GAAGJ,MAAM;IAC1CC,SAAS,CAACI,SAAS,GAAGC,MAAM,CAACC,MAAM,CAAEP,MAAM,IAAIA,MAAM,CAACK,SAAS,CAAE;IACjEJ,SAAS,CAACI,SAAS,CAACG,WAAW,GAAGP,SAAS;IAE3CA,SAAS,CAACI,SAAS,CAACI,iBAAiB,GAAG,SAASA,iBAAiB,CAAEC,uBAAuB,EAAE;MAC3F,IAAI,IAAI,CAACC,OAAO,CAACC,WAAW,IAAI,CAAC,KAAK,IAAI,CAACC,IAAI,IAAI1B,EAAE,CAAC2B,IAAI,IAAI,IAAI,CAACD,IAAI,IAAI,IAAI,CAACE,gBAAgB,IAAI,IAAI,CAACF,IAAI,IAAI1B,EAAE,CAAC6B,QAAQ,IAAI,IAAI,CAACH,IAAI,IAAI1B,EAAE,CAAC8B,MAAM,CAAC,EAAE;QACvJ,IAAIC,MAAM,GAAG,IAAI,CAACC,OAAO,EAAE;QAC3B,IAAID,MAAM,CAACL,IAAI,IAAI1B,EAAE,CAAC6B,QAAQ,EAAE;UAC9B,IAAII,KAAK,GAAG,CAAC;UACb,GAAG;YACD,IAAIF,MAAM,CAAC1B,GAAG,CAACL,EAAE,CAAC6B,QAAQ,CAAC,EAAE;cAAE,EAAEI,KAAK;YAAC,CAAC,MACnC,IAAIF,MAAM,CAAC1B,GAAG,CAACL,EAAE,CAACkC,QAAQ,CAAC,EAAE;cAAE,EAAED,KAAK;YAAC,CAAC,MACxC;cAAEF,MAAM,CAACI,IAAI,EAAE;YAAC;UACvB,CAAC,QAAQF,KAAK,GAAG,CAAC;QACpB,CAAC,MAAM;UAAEF,MAAM,CAACI,IAAI,EAAE;QAAC;QACvB,IAAIJ,MAAM,CAACL,IAAI,IAAI1B,EAAE,CAACM,EAAE,IAAIyB,MAAM,CAACK,kBAAkB,EAAE,IAAIL,MAAM,CAACL,IAAI,IAAI1B,EAAE,CAACqC,IAAI,EAAE;UACjF,IAAIC,IAAI,GAAG,IAAI,CAACC,SAAS,EAAE;UAC3B,IAAI,IAAI,CAACb,IAAI,IAAI,IAAI,CAACE,gBAAgB,EAAE;YACtC,IAAI,CAACY,4BAA4B,CAACF,IAAI,CAAC;UACzC,CAAC,MAAM;YACL,IAAI,CAACG,iBAAiB,CAACH,IAAI,CAAC;UAC9B;UACA,IAAKA,IAAI,CAACI,GAAG,CAAChB,IAAI,KAAK,YAAY,IAAIY,IAAI,CAACI,GAAG,CAACf,IAAI,KAAK,aAAa,IACjEW,IAAI,CAACI,GAAG,CAAChB,IAAI,KAAK,SAAS,IAAIY,IAAI,CAACI,GAAG,CAACjC,KAAK,KAAK,aAAc,EAAE;YACrE,IAAI,CAACkC,KAAK,CAACL,IAAI,CAACI,GAAG,CAACE,KAAK,EAAE,iDAAiD,CAAC;UAC/E;UACAzC,oBAAoB,CAAC0C,IAAI,CAAC,IAAI,EAAEP,IAAI,CAAC;UACrC,IAAI,CAACQ,UAAU,CAACR,IAAI,EAAE,iBAAiB,CAAC;UACxC,IAAI,CAACS,SAAS,EAAE;UAChB,OAAOT,IAAI;QACb;MACF;MAEA,OAAOzB,MAAM,CAACK,SAAS,CAACI,iBAAiB,CAACP,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IAClE,CAAC;;IAED;IACAF,SAAS,CAACI,SAAS,CAAC8B,UAAU,GAAG,SAASA,UAAU,CAAEC,OAAO,EAAEC,SAAS,EAAE;MACxE,IAAIC,KAAK,GAAGtC,MAAM,CAACK,SAAS,CAAC8B,UAAU,CAACH,IAAI,CAAC,IAAI,EAAEI,OAAO,EAAEC,SAAS,CAAC;MACtE,IAAI,IAAI,CAAC1C,aAAa,IAAI2C,KAAK,CAACxB,IAAI,IAAI,WAAW,EAAE;QAAE,IAAI,CAACgB,KAAK,CAACQ,KAAK,CAACP,KAAK,EAAE,qDAAqD,CAAC;MAAC;MACtI,OAAOO,KAAK;IACd,CAAC;IAED,OAAOrC,SAAS;EAClB,CAAC,CAACD,MAAM,CAAC;AACX,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}