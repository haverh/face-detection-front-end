{"ast":null,"code":"'use strict';\n\nvar SourceMapGenerator = require('source-map').SourceMapGenerator;\nfunction offsetMapping(mapping, offset) {\n  return {\n    line: offset.line + mapping.line,\n    column: offset.column + mapping.column\n  };\n}\nfunction newlinesIn(src) {\n  if (!src) return 0;\n  var newlines = src.match(/\\n/g);\n  return newlines ? newlines.length : 0;\n}\nfunction Generator(opts) {\n  opts = opts || {};\n  this.generator = new SourceMapGenerator({\n    file: opts.file || '',\n    sourceRoot: opts.sourceRoot || ''\n  });\n  this.sourcesContent = undefined;\n  this.opts = opts;\n}\n\n/**\n * Adds the given mappings to the generator and offsets them if offset is given \n *\n * @name addMappings\n * @function\n * @param sourceFile {String} name of the source file\n * @param mappings {Array{{Object}} each object has the form { original: { line: _, column: _ }, generated: { line: _, column: _ } }\n * @param offset {Object} offset to apply to each mapping. Has the form { line: _, column: _ }\n * @return {Object} the generator to allow chaining\n */\nGenerator.prototype.addMappings = function (sourceFile, mappings, offset) {\n  var generator = this.generator;\n  offset = offset || {};\n  offset.line = offset.hasOwnProperty('line') ? offset.line : 0;\n  offset.column = offset.hasOwnProperty('column') ? offset.column : 0;\n  mappings.forEach(function (m) {\n    // only set source if we have original position to handle edgecase (see inline-source-map tests)\n    generator.addMapping({\n      source: m.original ? sourceFile : undefined,\n      original: m.original,\n      generated: offsetMapping(m.generated, offset)\n    });\n  });\n  return this;\n};\n\n/**\n * Generates mappings for the given source, assuming that no translation from original to generated is necessary.\n *\n * @name addGeneratedMappings\n * @function\n * @param sourceFile {String} name of the source file\n * @param source {String} source of the file\n * @param offset {Object} offset to apply to each mapping. Has the form { line: _, column: _ }\n * @return {Object} the generator to allow chaining\n */\nGenerator.prototype.addGeneratedMappings = function (sourceFile, source, offset) {\n  var mappings = [],\n    linesToGenerate = newlinesIn(source) + 1;\n  for (var line = 1; line <= linesToGenerate; line++) {\n    var location = {\n      line: line,\n      column: 0\n    };\n    mappings.push({\n      original: location,\n      generated: location\n    });\n  }\n  return this.addMappings(sourceFile, mappings, offset);\n};\n\n/**\n * Adds source content for the given source file.\n * \n * @name addSourceContent\n * @function\n * @param sourceFile {String} The source file for which a mapping is included\n * @param sourcesContent {String} The content of the source file\n * @return {Object} The generator to allow chaining\n */\nGenerator.prototype.addSourceContent = function (sourceFile, sourcesContent) {\n  this.sourcesContent = this.sourcesContent || {};\n  this.sourcesContent[sourceFile] = sourcesContent;\n  return this;\n};\n\n/**\n * @name base64Encode\n * @function\n * @return {String} bas64 encoded representation of the added mappings\n */\nGenerator.prototype.base64Encode = function () {\n  var map = this.toString();\n  return new Buffer(map).toString('base64');\n};\n\n/**\n * @name inlineMappingUrl\n * @function\n * @return {String} comment with base64 encoded representation of the added mappings. Can be inlined at the end of the generated file. \n */\nGenerator.prototype.inlineMappingUrl = function () {\n  var charset = this.opts.charset || 'utf-8';\n  return '//# sourceMappingURL=data:application/json;charset=' + charset + ';base64,' + this.base64Encode();\n};\nGenerator.prototype.toJSON = function () {\n  var map = this.generator.toJSON();\n  if (!this.sourcesContent) return map;\n  var toSourcesContent = function (s) {\n    if (typeof this.sourcesContent[s] === 'string') {\n      return this.sourcesContent[s];\n    } else {\n      return null;\n    }\n  }.bind(this);\n  map.sourcesContent = map.sources.map(toSourcesContent);\n  return map;\n};\nGenerator.prototype.toString = function () {\n  return JSON.stringify(this);\n};\nGenerator.prototype._mappings = function () {\n  return this.generator._mappings._array;\n};\nGenerator.prototype.gen = function () {\n  return this.generator;\n};\nmodule.exports = function (opts) {\n  return new Generator(opts);\n};\nmodule.exports.Generator = Generator;","map":{"version":3,"names":["SourceMapGenerator","require","offsetMapping","mapping","offset","line","column","newlinesIn","src","newlines","match","length","Generator","opts","generator","file","sourceRoot","sourcesContent","undefined","prototype","addMappings","sourceFile","mappings","hasOwnProperty","forEach","m","addMapping","source","original","generated","addGeneratedMappings","linesToGenerate","location","push","addSourceContent","base64Encode","map","toString","Buffer","inlineMappingUrl","charset","toJSON","toSourcesContent","s","bind","sources","JSON","stringify","_mappings","_array","gen","module","exports"],"sources":["C:/Users/straw/Desktop/Personal CS Projects/ZTM/Web Developer Course/face-recognition/node_modules/inline-source-map/index.js"],"sourcesContent":["'use strict';\nvar SourceMapGenerator = require('source-map').SourceMapGenerator;\n\nfunction offsetMapping(mapping, offset) {\n  return { line: offset.line + mapping.line, column: offset.column + mapping.column };\n}\n\nfunction newlinesIn(src) {\n  if (!src) return 0;\n  var newlines = src.match(/\\n/g);\n\n  return newlines ? newlines.length : 0;\n}\n \nfunction Generator(opts) {\n  opts = opts || {};\n  this.generator = new SourceMapGenerator({ file: opts.file || '', sourceRoot: opts.sourceRoot || '' });\n  this.sourcesContent = undefined;\n  this.opts = opts;\n}\n\n/**\n * Adds the given mappings to the generator and offsets them if offset is given \n *\n * @name addMappings\n * @function\n * @param sourceFile {String} name of the source file\n * @param mappings {Array{{Object}} each object has the form { original: { line: _, column: _ }, generated: { line: _, column: _ } }\n * @param offset {Object} offset to apply to each mapping. Has the form { line: _, column: _ }\n * @return {Object} the generator to allow chaining\n */\nGenerator.prototype.addMappings = function (sourceFile, mappings, offset) { \n  var generator = this.generator; \n\n  offset = offset || {};\n  offset.line = offset.hasOwnProperty('line') ? offset.line : 0;\n  offset.column = offset.hasOwnProperty('column') ? offset.column : 0;\n\n  mappings.forEach(function (m) {\n    // only set source if we have original position to handle edgecase (see inline-source-map tests)\n    generator.addMapping({\n        source    :  m.original ? sourceFile : undefined\n      , original  :  m.original\n      , generated :  offsetMapping(m.generated, offset)\n    });\n  });\n  return this;\n};\n\n/**\n * Generates mappings for the given source, assuming that no translation from original to generated is necessary.\n *\n * @name addGeneratedMappings\n * @function\n * @param sourceFile {String} name of the source file\n * @param source {String} source of the file\n * @param offset {Object} offset to apply to each mapping. Has the form { line: _, column: _ }\n * @return {Object} the generator to allow chaining\n */\nGenerator.prototype.addGeneratedMappings = function (sourceFile, source, offset) {\n  var mappings = []\n    , linesToGenerate = newlinesIn(source) + 1;\n\n  for (var line = 1; line <= linesToGenerate; line++) {\n    var location = { line: line, column: 0 };\n    mappings.push({ original: location, generated: location });\n  }\n\n  return this.addMappings(sourceFile, mappings, offset);\n};\n\n/**\n * Adds source content for the given source file.\n * \n * @name addSourceContent\n * @function\n * @param sourceFile {String} The source file for which a mapping is included\n * @param sourcesContent {String} The content of the source file\n * @return {Object} The generator to allow chaining\n */\nGenerator.prototype.addSourceContent = function (sourceFile, sourcesContent) {\n  this.sourcesContent = this.sourcesContent || {};\n  this.sourcesContent[sourceFile] = sourcesContent;\n  return this;\n};\n\n/**\n * @name base64Encode\n * @function\n * @return {String} bas64 encoded representation of the added mappings\n */\nGenerator.prototype.base64Encode = function () {\n  var map = this.toString();\n  return new Buffer(map).toString('base64');\n};\n\n/**\n * @name inlineMappingUrl\n * @function\n * @return {String} comment with base64 encoded representation of the added mappings. Can be inlined at the end of the generated file. \n */\nGenerator.prototype.inlineMappingUrl = function () {\n  var charset = this.opts.charset || 'utf-8';\n  return '//# sourceMappingURL=data:application/json;charset=' + charset + ';base64,' + this.base64Encode();\n};\n\nGenerator.prototype.toJSON = function () {\n  var map = this.generator.toJSON();\n  if (!this.sourcesContent) return map;\n\n  var toSourcesContent = (function (s) {\n    if (typeof this.sourcesContent[s] === 'string') {\n      return this.sourcesContent[s];\n    } else {\n      return null;\n    }\n  }).bind(this);\n  map.sourcesContent = map.sources.map(toSourcesContent);\n  return map;\n};\n\nGenerator.prototype.toString = function () {\n  return JSON.stringify(this);\n};\n\nGenerator.prototype._mappings = function () {\n  return this.generator._mappings._array;\n};\n\nGenerator.prototype.gen = function () {\n  return this.generator;\n};\n\nmodule.exports = function (opts) { return new Generator(opts); };\nmodule.exports.Generator = Generator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}