{"ast":null,"code":"var xtend = require('xtend');\nvar acorn = require('acorn-node');\nvar dash = require('dash-ast');\nvar getAssignedIdentifiers = require('get-assigned-identifiers');\nfunction visitFunction(node, state, ancestors) {\n  if (node.params.length > 0) {\n    var idents = [];\n    for (var i = 0; i < node.params.length; i++) {\n      var sub = getAssignedIdentifiers(node.params[i]);\n      for (var j = 0; j < sub.length; j++) idents.push(sub[j]);\n    }\n    declareNames(node, idents);\n  }\n  if (node.type === 'FunctionDeclaration') {\n    var parent = getScopeNode(ancestors, 'const');\n    declareNames(parent, [node.id]);\n  } else if (node.type === 'FunctionExpression' && node.id) {\n    declareNames(node, [node.id]);\n  }\n}\nvar scopeVisitor = {\n  VariableDeclaration: function (node, state, ancestors) {\n    var parent = getScopeNode(ancestors, node.kind);\n    for (var i = 0; i < node.declarations.length; i++) {\n      declareNames(parent, getAssignedIdentifiers(node.declarations[i].id));\n    }\n  },\n  FunctionExpression: visitFunction,\n  FunctionDeclaration: visitFunction,\n  ArrowFunctionExpression: visitFunction,\n  ClassDeclaration: function (node, state, ancestors) {\n    var parent = getScopeNode(ancestors, 'const');\n    if (node.id) {\n      declareNames(parent, [node.id]);\n    }\n  },\n  ImportDeclaration: function (node, state, ancestors) {\n    declareNames(ancestors[0] /* root */, getAssignedIdentifiers(node));\n  },\n  CatchClause: function (node) {\n    if (node.param) declareNames(node, [node.param]);\n  }\n};\nvar bindingVisitor = {\n  Identifier: function (node, state, ancestors) {\n    if (!state.identifiers) return;\n    var parent = ancestors[ancestors.length - 1];\n    if (parent.type === 'MemberExpression' && parent.property === node) return;\n    if (parent.type === 'Property' && !parent.computed && parent.key === node) return;\n    if (parent.type === 'MethodDefinition' && !parent.computed && parent.key === node) return;\n    if (parent.type === 'LabeledStatement' && parent.label === node) return;\n    if (!has(state.undeclared, node.name)) {\n      for (var i = ancestors.length - 1; i >= 0; i--) {\n        if (ancestors[i]._names !== undefined && has(ancestors[i]._names, node.name)) {\n          return;\n        }\n      }\n      state.undeclared[node.name] = true;\n    }\n    if (state.wildcard && !(parent.type === 'MemberExpression' && parent.object === node) && !(parent.type === 'VariableDeclarator' && parent.id === node) && !(parent.type === 'AssignmentExpression' && parent.left === node)) {\n      state.undeclaredProps[node.name + '.*'] = true;\n    }\n  },\n  MemberExpression: function (node, state) {\n    if (!state.properties) return;\n    if (node.object.type === 'Identifier' && has(state.undeclared, node.object.name)) {\n      var prop = !node.computed && node.property.type === 'Identifier' ? node.property.name : node.computed && node.property.type === 'Literal' ? node.property.value : null;\n      if (prop) state.undeclaredProps[node.object.name + '.' + prop] = true;\n    }\n  }\n};\nmodule.exports = function findUndeclared(src, opts) {\n  opts = xtend({\n    identifiers: true,\n    properties: true,\n    wildcard: false\n  }, opts);\n  var state = {\n    undeclared: {},\n    undeclaredProps: {},\n    identifiers: opts.identifiers,\n    properties: opts.properties,\n    wildcard: opts.wildcard\n  };\n\n  // Parse if `src` is not already an AST.\n  var ast = typeof src === 'object' && src !== null && typeof src.type === 'string' ? src : acorn.parse(src);\n  var parents = [];\n  dash(ast, {\n    enter: function (node, parent) {\n      if (parent) parents.push(parent);\n      var visit = scopeVisitor[node.type];\n      if (visit) visit(node, state, parents);\n    },\n    leave: function (node, parent) {\n      var visit = bindingVisitor[node.type];\n      if (visit) visit(node, state, parents);\n      if (parent) parents.pop();\n    }\n  });\n  return {\n    identifiers: Object.keys(state.undeclared),\n    properties: Object.keys(state.undeclaredProps)\n  };\n};\nfunction getScopeNode(parents, kind) {\n  for (var i = parents.length - 1; i >= 0; i--) {\n    if (parents[i].type === 'FunctionDeclaration' || parents[i].type === 'FunctionExpression' || parents[i].type === 'ArrowFunctionExpression' || parents[i].type === 'Program') {\n      return parents[i];\n    }\n    if (kind !== 'var' && parents[i].type === 'BlockStatement') {\n      return parents[i];\n    }\n  }\n}\nfunction declareNames(node, names) {\n  if (node._names === undefined) {\n    node._names = Object.create(null);\n  }\n  for (var i = 0; i < names.length; i++) {\n    node._names[names[i].name] = true;\n  }\n}\nfunction has(obj, name) {\n  return Object.prototype.hasOwnProperty.call(obj, name);\n}","map":{"version":3,"names":["xtend","require","acorn","dash","getAssignedIdentifiers","visitFunction","node","state","ancestors","params","length","idents","i","sub","j","push","declareNames","type","parent","getScopeNode","id","scopeVisitor","VariableDeclaration","kind","declarations","FunctionExpression","FunctionDeclaration","ArrowFunctionExpression","ClassDeclaration","ImportDeclaration","CatchClause","param","bindingVisitor","Identifier","identifiers","property","computed","key","label","has","undeclared","name","_names","undefined","wildcard","object","left","undeclaredProps","MemberExpression","properties","prop","value","module","exports","findUndeclared","src","opts","ast","parse","parents","enter","visit","leave","pop","Object","keys","names","create","obj","prototype","hasOwnProperty","call"],"sources":["C:/Users/straw/Desktop/Personal CS Projects/ZTM/Web Developer Course/face-recognition/node_modules/undeclared-identifiers/index.js"],"sourcesContent":["var xtend = require('xtend')\nvar acorn = require('acorn-node')\nvar dash = require('dash-ast')\nvar getAssignedIdentifiers = require('get-assigned-identifiers')\n\nfunction visitFunction (node, state, ancestors) {\n  if (node.params.length > 0) {\n    var idents = []\n    for (var i = 0; i < node.params.length; i++) {\n      var sub = getAssignedIdentifiers(node.params[i])\n      for (var j = 0; j < sub.length; j++) idents.push(sub[j])\n    }\n    declareNames(node, idents)\n  }\n  if (node.type === 'FunctionDeclaration') {\n    var parent = getScopeNode(ancestors, 'const')\n    declareNames(parent, [node.id])\n  } else if (node.type === 'FunctionExpression' && node.id) {\n    declareNames(node, [node.id])\n  }\n}\n\nvar scopeVisitor = {\n  VariableDeclaration: function (node, state, ancestors) {\n    var parent = getScopeNode(ancestors, node.kind)\n    for (var i = 0; i < node.declarations.length; i++) {\n      declareNames(parent, getAssignedIdentifiers(node.declarations[i].id))\n    }\n  },\n  FunctionExpression: visitFunction,\n  FunctionDeclaration: visitFunction,\n  ArrowFunctionExpression: visitFunction,\n  ClassDeclaration: function (node, state, ancestors) {\n    var parent = getScopeNode(ancestors, 'const')\n    if (node.id) {\n      declareNames(parent, [node.id])\n    }\n  },\n  ImportDeclaration: function (node, state, ancestors) {\n    declareNames(ancestors[0] /* root */, getAssignedIdentifiers(node))\n  },\n  CatchClause: function (node) {\n    if (node.param) declareNames(node, [node.param])\n  }\n}\n\nvar bindingVisitor = {\n  Identifier: function (node, state, ancestors) {\n    if (!state.identifiers) return\n    var parent = ancestors[ancestors.length - 1]\n    if (parent.type === 'MemberExpression' && parent.property === node) return\n    if (parent.type === 'Property' && !parent.computed && parent.key === node) return\n    if (parent.type === 'MethodDefinition' && !parent.computed && parent.key === node) return\n    if (parent.type === 'LabeledStatement' && parent.label === node) return\n    if (!has(state.undeclared, node.name)) {\n      for (var i = ancestors.length - 1; i >= 0; i--) {\n        if (ancestors[i]._names !== undefined && has(ancestors[i]._names, node.name)) {\n          return\n        }\n      }\n\n      state.undeclared[node.name] = true\n    }\n\n    if (state.wildcard &&\n        !(parent.type === 'MemberExpression' && parent.object === node) &&\n        !(parent.type === 'VariableDeclarator' && parent.id === node) &&\n        !(parent.type === 'AssignmentExpression' && parent.left === node)) {\n      state.undeclaredProps[node.name + '.*'] = true\n    }\n  },\n  MemberExpression: function (node, state) {\n    if (!state.properties) return\n    if (node.object.type === 'Identifier' && has(state.undeclared, node.object.name)) {\n      var prop = !node.computed && node.property.type === 'Identifier'\n        ? node.property.name\n        : node.computed && node.property.type === 'Literal'\n          ? node.property.value\n          : null\n      if (prop) state.undeclaredProps[node.object.name + '.' + prop] = true\n    }\n  }\n}\n\nmodule.exports = function findUndeclared (src, opts) {\n  opts = xtend({\n    identifiers: true,\n    properties: true,\n    wildcard: false\n  }, opts)\n\n  var state = {\n    undeclared: {},\n    undeclaredProps: {},\n    identifiers: opts.identifiers,\n    properties: opts.properties,\n    wildcard: opts.wildcard\n  }\n\n  // Parse if `src` is not already an AST.\n  var ast = typeof src === 'object' && src !== null && typeof src.type === 'string'\n    ? src\n    : acorn.parse(src)\n\n  var parents = []\n  dash(ast, {\n    enter: function (node, parent) {\n      if (parent) parents.push(parent)\n      var visit = scopeVisitor[node.type]\n      if (visit) visit(node, state, parents)\n    },\n    leave: function (node, parent) {\n      var visit = bindingVisitor[node.type]\n      if (visit) visit(node, state, parents)\n      if (parent) parents.pop()\n    }\n  })\n\n  return {\n    identifiers: Object.keys(state.undeclared),\n    properties: Object.keys(state.undeclaredProps)\n  }\n}\n\nfunction getScopeNode (parents, kind) {\n  for (var i = parents.length - 1; i >= 0; i--) {\n    if (parents[i].type === 'FunctionDeclaration' || parents[i].type === 'FunctionExpression' ||\n        parents[i].type === 'ArrowFunctionExpression' || parents[i].type === 'Program') {\n      return parents[i]\n    }\n    if (kind !== 'var' && parents[i].type === 'BlockStatement') {\n      return parents[i]\n    }\n  }\n}\n\nfunction declareNames (node, names) {\n  if (node._names === undefined) {\n    node._names = Object.create(null)\n  }\n  for (var i = 0; i < names.length; i++) {\n    node._names[names[i].name] = true\n  }\n}\n\nfunction has (obj, name) { return Object.prototype.hasOwnProperty.call(obj, name) }\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}